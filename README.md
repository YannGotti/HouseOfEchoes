# House of Echoes — Архитектура проекта

Данный документ описывает архитектурную структуру игры **House of Echoes** — трёхмерного хоррора с полулинейным сюжетом, кат-сценами и поддержкой многопользовательского режима. Архитектура построена на принципах модульности, слабой связанности, чёткого разделения ответственности и расширяемости.

---

## Содержание

- [Основные принципы](#основные-принципы)
- [Ядро (Core)](#ядро-core)
- [Подсистема игрока (Player)](#подсистема-игрока-player)
- [Анимационная система](#анимационная-система)
- [Искусственный интеллект (AI)](#искусственный-интеллект-ai)
- [Окружение (World)](#окружение-world)
- [Игровые системы (Features)](#игровые-системы-features)
- [Сетевая подсистема](#сетевая-подсистема)
- [Структура проекта](#структура-проекта)

---

## Основные принципы

- **Единая ответственность**: каждый класс решает ровно одну задачу.
- **Слабая связанность**: модули взаимодействуют через события или интерфейсы, а не напрямую.
- **Композиция вместо наследования**: поведение собирается из независимых компонентов.
- **Независимость от сети**: игровая логика одинакова в одиночной и сетевой игре.
- **Тестируемость**: физика, ИИ и машины состояний могут тестироваться вне Unity.

---

## Ядро (Core)

### Машина состояний игры (`GameStateMachine`)

Центральный регулятор контекста игры. Управляет глобальными режимами:

- **Explore** — стандартный геймплей (движение, взаимодействие).
- **Cinematic** — кат-сцены (ввод отключён, камера управляема).
- **Combat** — повышенная активность ИИ.
- **Pause** — пауза (UI активен, физика остановлена).

Предотвращает конфликты (например, движение во время кат-сцены). Реализует паттерн *Game State Machine*, широко используемый в AAA-играх.

### Глобальная шина событий (`GlobalEventBus`)

Статический агрегатор событий, реализующий паттерны *Mediator* и *Observer*.

- События — **сигналы**, а не команды.
- Передаются только примитивы (ID, тип, булевы значения).
- Логические каналы: `Gameplay`, `World`, `AI`.

Пример:
```csharp
if (Input.GetButtonDown("Interact"))
    GlobalEventBus.OnInteractRequested?.Invoke();
```

Обеспечивает слабую связанность между системами: игрок, двери, UI, звук и ИИ не ссылаются друг на друга напрямую.

### Система сохранения (`ISaveable`)

Интерфейс для всех сущностей, поддерживающих сохранение:

```csharp
public interface ISaveable
{
    void Save();
    void Load();
}
```

Реализуется `Player`, `GameState`, `Inventory`. Позволяет единообразно обрабатывать сохранение без знания конкретного типа объекта (принцип *Dependency Inversion*).

---

## Подсистема игрока (Player)

### Контроллер игрока (`PlayerController`)

Выступает в роли **фасада** — координирует подсистемы, но не содержит игровой логики.

В методе `Update()`:
1. Получает данные от `PlayerInputHandler`.
2. Передаёт вектор движения в `PlayerMotor`.
3. Обновляет параметры анимации через `PlayerAnimator`.
4. Управляет режимом камеры через `ThirdPersonCamera`.
5. Проверяет возможность взаимодействия.

Не содержит проверок здоровья, боезапаса или сетевой логики.

### Обработчик ввода (`PlayerInputHandler`)

Адаптер над Unity Input System. Возвращает нормализованный вектор движения и состояние прицеливания. Активен только у локального игрока в сетевой игре.

### Двигатель перемещения (`PlayerMotor`)

Чистая логика перемещения через `CharacterController.SimpleMove()`. Учитывает наклон поверхности и ограничивает скорость на склонах. Не знает об анимациях, камере или здоровье.

### Система камеры (`ThirdPersonCamera`)

Управляет тремя режимами с плавными переходами:
- **TPS** — вид от третьего лица.
- **FPS** — прицеливание.
- **Cinematic** — управляемая камера в кат-сценах.

Использует `SmoothDamp` и ограничивает углы обзора, чтобы избежать бесконечного вращения.

### Прокси аниматора (`PlayerAnimator`)

Единственная точка входа в анимационную систему. Все вызовы к `Animator` проходят через этот класс. Гарантирует отсутствие конфликтов параметров и соблюдение закона Деметры.

### Сетевой адаптер (`PlayerNetworkHandler`)

Единственный `NetworkBehaviour` на префабе игрока. Изолирует Mirror от основной логики:
- Обрабатывает ввод только у локального игрока.
- Валидирует действия на сервере через `[Command]`.
- Синхронизирует эффекты через `[ClientRpc]`.

---

## Анимационная система

Игрок использует многослойный `Animator Controller`:

- **Base Layer**: Locomotion (Idle, Walk Forward/Backward, Strafe).
- **UpperBody Layer**: Прицеливание и стрельба (только верх тела).
- **FX Layer**: Эмоции и реакции на урон (полное тело).

Все переходы прерываемые (`Has Exit Time = false`). Для оружия используются **Animator Override Controllers**, что позволяет переопределять только нужные анимации без дублирования всего контроллера.

---

## Искусственный интеллект (AI)

### Машина состояний врага (`EnemyFSM`)

Реализует паттерн *State Machine* с состояниями:
- `Idle` → `Patrol` → `Alert` → `Chase` → `Attack`.

Переходы управляются событиями восприятия (`OnSeePlayer`, `OnHearNoise`). Каждое состояние — отдельный класс (*State Pattern*).

### Агент ИИ (`EnemyBase`)

Полный ИИ-агент одного врага. Инкапсулирует:
- Систему восприятия (зрение, слух).
- FSM.
- Аниматор.
- Систему здоровья.

Может существовать сотнями независимо.

### Режиссёр ИИ (`AIDirector`)

Глобальный регулятор напряжения, вдохновлённый *Resident Evil*. Отслеживает количество угроз, управляет спавном и влияет на эмоции игрока через `EmotionManager`.

---

## Окружение (World)

Все интерактивные объекты реализуют интерфейс:

```csharp
public interface IInteractable
{
    void Interact(PlayerController player);
}
```

Примеры:
- **Door**: проверяет наличие ключа, открывается, публикует событие `OnDoorOpened`.
- **Lever**: переключает состояние, уведомляет `PuzzleManager`.

`PlayerController` вызывает `.Interact(this)` полиморфно, не зная конкретный тип объекта.

---

## Игровые системы (Features)

### Система оружия

Разделена на два слоя:
- **`WeaponManager`**: чистая игровая логика (экипировка, выстрел).
- **`WeaponNetworkAdapter`**: сетевой слой (валидация, синхронизация).

Оружие определяется через `ScriptableObject` (`WeaponData`), что позволяет настраивать баланс без изменения кода.

### Система эмоций

Добавляет «живость» персонажу в моменты простоя:
- Срабатывает только в состоянии Idle.
- Отключается в режимах Cinematic и Combat.
- Реагирует на события мира (например, появление монстра → испуг).

### Система головоломок

Централизована в `PuzzleManager`. Все головоломки реализуют `IPuzzle`. Успешное решение публикует событие `OnPuzzleSolved`, которое могут перехватывать двери, триггеры и сюжетные системы.

---

## Сетевая подсистема

### Сессия игры (`NetworkGameSession`)

Точка входа в сетевую игру. Запускает хост или клиент, инициализирует Mirror и спавнит игрока.

### Состояние матча (`SyncedGameState`)

Хранит данные сессии на сервере:
- `matchId`
- `isMatchActive`
- список игроков

Синхронизируется через `SyncVar` и RPC. Является чистым DTO, не наследует `MonoBehaviour`.

---

## Структура проекта

```
Assets/
├── Core/
├── Player/
├── Animation/
│   └── Controllers/
├── AI/
├── World/
├── Features/
├── Data/
│   ├── Weapons/
│   └── Puzzles/
└── Networking/
```

Каждая папка содержит соответствующие скрипты, ассеты и (опционально) `.asmdef` файлы для управления зависимостями.

